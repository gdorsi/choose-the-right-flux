<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Create your own flux</title>
        <link href="https://fonts.googleapis.com/css?family=Roboto:400,500" rel="stylesheet">
        <link rel="stylesheet" href="dist/index.css">
	</head>
	<body>
		<section class="active">
			<h1>Choose the right Flux!</h1>
			<p>
				In a kingdom rich of async calls and complexity,
				only the right hero can bring peace and scalability.
			</p>
			<p>
				Flux can be the right choice, but there are hundreds implementations and we must choose the right one.
			</p>
			<div class="bottom-left">
				Guido D'Orsi @ RomaJS
			</div>
		</section>
		<section>
			<p class="hidden-note">
				Tanto tempo fa, in una piccola interfaccia, regnava la pace e la serenità.
				Non c'era una vera e propria organizzazione, ma i componenti erano pochi e gestirli era abbastanza facile.
			</p>
			<p class="text-center">
				<img src="basic-interface.svg" style="width: 50vw; height: 50vh;">
			</p>
		</section>
		<section>
			<p class="hidden-note">Poi però l'applicazione crebbe, i componenti iniziarono a diventare tanti.
				Iniziarono ad uscire fuori i primi bug, ma correggerli non faceva altro che aumentare la complessità del sistema.</p>
			<p class="text-center">
				<img src="medium-interface.svg" style="width: 50vw; height: 50vh;">
			</p>
		</section>
		<section>
			<p class="hidden-note">Le feature aumentarono e con esse anche il caos, quindi si decise di dare un pò di organizzazione.
				Venne utilizzato il pattern MVC</p>
		</section>
		<section>
			<p class="hidden-note">Però il cambiamento non veniva visto di buon occhio. Era difficile dire chi doveva essere il Controller, chi il Model e chi la View</p>
		</section>
		<section>
			<p class="hidden-note">Poi qualche pazzo ci mise dentro anche il two way data binding. Il Controller iniziava a diventare enorme e pieno di responsabilità,
				e quando una View tentava di parlare con un Model succedeva il finimondo.</p>
		</section>
		<section>
			<p class="hidden-note">Fu così che si decise di dare una svolta, scegliendo un pattern completamente nuovo, Flux</p>
		</section>
		<section>
			<p class="hidden-note">Con Flux ognuno aveva un compito ben delineato, e sapeva bene con chi parlare e chi ascoltare.</p>
		</section>
		<section>
			<p class="hidden-note">La View parla con gli Actions Creators, che, dopo aver fatto un bel discorsetto con le Web API, e creano azioni da mandare al Dispatcher, che a sua volta la propaga a tutti gli store.
				Gli Store prendono le action e aggiornano lo stato dell'applicazione.
				Dopo che hanno fatto tutto raccontano le modifiche alla View che fermano il giro e mostrano il nuovo stato al'utente.</p>
			<img class="responsive" src="http://facebook.github.io/flux/img/flux-simple-f8-diagram-with-client-action-1300w.png">
		</section>
		<section>
			<p class="hidden-note">
				Come implementare Flux?
				Ci scegliamo una libreria o ci facciamo una cosa nostra?
				Io penso che l'unico modo per utilizzare una tecnologia è conoscerla bene,
				per questo oggi voglio provare ad analizzare quelle che possono essere le scelte principali
				che vanno effettuate quando si sceglie di utilizzare Flux.
			</p>
		</section>
		<section>
			<p class="hidden-note">
				Iniziamo col rispondere alla domanda che cos'è un action?
				Abbiamo capito che è il messaggio che viene creato su richesta delle View e spedito a tutti gli store,
				ma come sono fatte?
			</p>
		</section>
		<section>
			<p class="code">
{
	type: 'ADD_TODO',
	data: actionData
}
			</p>
			<p class="hidden-note">
				Un'action è solitamente un oggetto plain, ma si ha totale libertà su come definirla.
				L'unica cosa comune a tutte le implementazioni Flux è l'attributo type, valorizzato con una stringa in snake upper case
			</p>
		</section>
		<section>
			<p class="code">
{
	type: 'ADD_TODO',
	payload: actionData,
	meta: actionMeta
},
{
	type: 'ADD_TODO',
	payload: new Error(),
	error: true
}
			</p>
			<p class="hidden-note">
				Se si vuole c'è anche un pattern per le action, chiamto Flux Standard Action.
			</p>
		</section>
		<section>
			<p class="hidden-note">
				Abbiamo parlato di actions, che sono i messaggi.
				Questi messaggi, come abbiamo già detto vengono generati dagli action creators.
				In poche parole sono delle funzioni che generano delle action e a volte ne richiedono anche il dispatch.
			</p>
			<p class="code">
const addTodo = (todo) => {
	dispatch({
		type: 'ADD_TODO',
		payload: todo
	});
};
			</p>
		</section>
		<section>
			<p class="hidden-note">
				Ma l'asincrono?
			</p>
			<p class="code">
const addTodo = (todo) => {
	saveToDoWebApi(todo)
			.then((todo) => {
				dispatch({
					type: 'ADD_TODO',
					payload: todo
				});
			})
			.catch(() => {
				dispatch({
					type: 'ADD_TODO',
					payload: new Error('damn'),
					error: true
				});
			});
};
			</p>
		</section>
		<section>
			<p class="hidden-note">
				Così diventa facile anche fare optimistic updates
			</p>
			<p class="code">
const addTodo = (todo) => {
	dispatch({
		type: 'ADD_TODO',
		payload: todo
	});
	saveToDoWebApi(todo)
			.catch(() => {
				dispatch({
					type: 'REMOVE_TODO',
					payload: todo
				});
			});
};
			</p>
		</section>
		<section>
			<p class="code">
const addTodo = (todo) => ({
	type: 'ADD_TODO',
	payload: todo
});

dispatch(addTodo(myPrettyTodo));
			</p>
		</section>
		<section>
			<p class="hidden-note">
				Beh però qua per gestire l'asincrono dobbiamo introdurre un concetto nuovo.
				Il middleware.
				I middleware non sono nient'altro che funzioni che si trovano tra l'action creator e il dispatch vero e
				proprio.
			</p>
			<p class="code">
const addTodo = (todo) => ({
	type: 'ADD_TODO',
	payload: saveToDoWebApi(todo)
});

resolvePromise(dispatch, addTodo(myPrettyTodo));
			</p>
		</section>
		<section>
			Flux variants
		</section>
		<section>
			Code demo (This slides!)
		</section>
		<div class="progress"></div>
		<div class="controls">
			<svg xmlns="http://www.w3.org/2000/svg" version="1.1" class="prev">
				<polygon points="0,10 20,20 20,0"/>
			</svg>
			<svg xmlns="http://www.w3.org/2000/svg" version="1.1" class="next">
				<polygon points="0,0 0,20 20,10"/>
			</svg>
		</div>
		<script src="dist/index.js"></script>
	</body>
</html>
