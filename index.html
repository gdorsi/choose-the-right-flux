<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Create your own flux</title>
        <link href="https://fonts.googleapis.com/css?family=Roboto:400,500" rel="stylesheet">
        <link rel="stylesheet" href="dist/index.css">
	</head>
	<body>
		<section class="active">
			<h1>Choose the right Flux!</h1>
			<p>
				In a kingdom rich of async calls and complexity,
				only the right hero can bring peace and scalability.
			</p>
			<p>
				Flux can be the right choice, but there are hundreds implementations and we must choose the right one.
			</p>
			<div class="bottom-left">
				Guido D'Orsi @ RomaJS
			</div>
		</section>
		<section>
			<p>
				Tanto tempo fa, in una piccola interfaccia, regnava la pace e la serenità.
				Non c'era una vera e propria organizzazione, ma i componenti erano pochi e gestirli era abbastanza facile.
			</p>
		</section>
		<section>
			<p>Poi però l'applicazione crebbe, i componenti iniziarono a diventare tanti.
				Iniziarono ad uscire fuori i primi bug, ma correggerli non faceva altro che aumentare la complessità del sistema.</p>
		</section>
		<section>
			<p>Le feature aumentarono e con esse anche il caos, quindi si decise di dare un pò di organizzazione.
				Venne utilizzato il pattern MVC</p>
		</section>
		<section>
			<p>Però il cambiamento non veniva visto di buon occhio. Era difficile dire chi doveva essere il Controller, chi il Model e chi la View</p>
		</section>
		<section>
			<p>Poi qualche pazzo ci mise dentro anche il two way data binding. Il Controller iniziava a diventare enorme e pieno di responsabilità,
				e quando una View tentava di parlare con un Model succedeva il finimondo.</p>
		</section>
		<section>
			<p>Fu così che si decise di dare una svolta, scegliendo un pattern completamente nuovo, Flux</p>
		</section>
		<section>
			<p>Con Flux ognuno aveva un compito ben delineato, e sapeva bene con chi parlare e chi ascoltare.</p>
		</section>
		<section>
			<p>La View parla con gli Actions Creators, che, dopo aver fatto un bel discorsetto con le Web API, e creano azioni da mandare al Dispatcher, che a sua volta la propaga a tutti gli store.
				Gli Store prendono le action e aggiornano lo stato dell'applicazione.
				Dopo che hanno fatto tutto raccontano le modifiche alla View che fermano il giro e mostrano il nuovo stato al'utente.</p>
			<img class="responsive" src="http://facebook.github.io/flux/img/flux-simple-f8-diagram-with-client-action-1300w.png">
		</section>
		<section>
			<p>Però poi ci si rese conto che c'erano un sacco di modi per implementare Flux.
				Perchè gli store dovevano essere tanti?
				Non può essere solo uno?
				Come devono memorizzare lo stato?
				Come devono raccontare le modifiche alla View?
				E le actions che struttura devono avere?</p>
		</section>
		<section>
			<p>
				Fu così che le librerie su Flux iniziarono a fiorire, milioni e milioni di implementazioni.
				Ognuna buona sotto certi aspetti, ognuna brillante.
				Ma come scegliere quella giusta per la nostra applicazione?
			</p>
		</section>
		<section>
			<p>
				Per capire meglio le motivazioni di alcune scelte si decise di sperimentare.
				Creando una nuova implementazione di Flux, la nostra, cucita addosso la nostra interfaccia
			</p>
		</section>
		<section>
			<p>
				Iniziamo col rispondere alla domanda che cos'è un action?
				Abbiamo capito che è il messaggio che viene creato su richesta delle View e spedito a tutti gli store,
				ma come sono fatte?
			</p>
		</section>
		<section>
			<p class="code">
				{
					type: 'MY_TYPE',
					data: actionData
				}
			</p>
			<p>
				Un'action è solitamente un oggetto plain, ma si ha totale libertà su come definirla.
				L'unica cosa comune a tutte le implementazioni Flux è l'attributo type, valorizzato con una stringa in snake upper case
			</p>
		</section>
		<section>
			<p class="code">
				{
					type: 'MY_TYPE',
					payload: actionData,
					meta: actionMeta
				},
				{
					type: 'MY_TYPE',
					payload: Error,
					error: true
				}
			</p>
			<p>
				A qualcuno però questa troppa libertà non piaceva, così si è inventato un pattern nel pattern, le FSA.
				Definire un pattern per le action ha dato vita a un ecosistema di funzioni helper utili.
			</p>
		</section>
		<section>

		</section>
		<section>
			How to choose a Flux library or Create your own
		</section>
		<section>
			Flux variants
		</section>
		<section>
			Code demo (This slides!)
		</section>
		<div class="progress"></div>
		<div class="controls">
			<svg xmlns="http://www.w3.org/2000/svg" version="1.1" class="prev">
				<polygon points="0,10 20,20 20,0"/>
			</svg>
			<svg xmlns="http://www.w3.org/2000/svg" version="1.1" class="next">
				<polygon points="0,0 0,20 20,10"/>
			</svg>
		</div>
		<script src="dist/index.js"></script>
	</body>
</html>
